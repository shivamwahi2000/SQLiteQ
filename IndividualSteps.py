# -*- coding: utf-8 -*-
"""SQLite.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12HSz2DXsQSX3zhmiuQCpEIIABExptztW

# SQLite

SQLite is a relational database management system (RDBMS) that is:

*   **Serverless:** Unlike other database systems like MySQL or PostgreSQL, SQLite doesn't require a separate server process. It operates directly on a single file.
*   **Self-contained:** The entire database is stored in a single file, making it easy to manage and transport.
*   **Zero-configuration:**  You don't need to install or configure a database server. It's ready to use right away.
*   **Embedded:** It's designed to be embedded within applications, making it a popular choice for mobile apps, desktop software, and web browsers.

## Use Cases

*   **Application Databases:** SQLite is often used as an application's database, especially for single-user applications, mobile apps, and embedded systems where a full-fledged database server is not needed.
*   **Local Data Storage:** Applications can use SQLite to store data locally, such as user settings, application data, or cached information.
*   **Testing and Development:** SQLite can be a convenient database for testing and development.
*   **Data Analysis:** It is often used to analyze datasets, and can be easily integrated with Python and R.
*   **Web Development:** SQLite can be used to prototype web applications and is also suitable for low-traffic websites.

## Key Features
*   **ACID properties:** SQLite databases are ACID-compliant (Atomicity, Consistency, Isolation, Durability).
*   **SQL Support:** SQLite supports standard SQL syntax.
*   **Python standard library:** It is included in the Python standard library, so you don't need to install anything to start using it in Python.

## How to use in Google Colab

To use SQLite in Google Colab, you can use the `sqlite3` library which is built into Python, or use the `ipython-sql` library to write SQL directly in cells.
"""

import sqlite3 as sql #to import SQLite3

conn =  sql.connect("customer.db") #to create a database and connect to it

cur = conn.cursor() #to create a cursor and execute SQL queries

"""**SQLite** has a dynamic type system, which means that the data type of a value is not determined by the column it's stored in. Here's a breakdown of the common data types:

1. **INTEGER**: This is used to store whole numbers.
2. **REAL**: This is used to store floating-point numbers.
3. **TEXT**: This is used to store strings of characters.
4. **BLOB**: This is used to store binary data.
5. **NULL**

Even though SQLite has only these five basic types, it can still store other types of data by converting them to one of these five.
"""

#Create a table in customer.db
cur.execute("""CREATE TABLE Customers(
  f_name text,
  l_name text,
  email text,
  age integer,
  city text,
  state text,
  zip integer,
  phone integer
)
""")

#Insert a Single Value
cur.execute("INSERT INTO Customers VALUES ('Radha','Krishnan','rk123@gmail.com',24,'Delhi','Delhi',110032,7825649371)")

#Insert Multiple Values
Customers =  [
    ('Amit', 'Sharma', 'amit.sharma89@gmail.com', 30, 'Mumbai', 'Maharashtra', 400001, 9812345678),
    ('Priya', 'Singh', 'priya.singh77@yahoo.com', 27, 'Bangalore', 'Karnataka', 560001, 9987654321),
    ('Rahul', 'Verma', 'rahul.verma91@hotmail.com', 32, 'Chennai', 'Tamil Nadu', 600001, 8876543210),
    ('Sneha', 'Patel', 'sneha.patel123@gmail.com', 25, 'Ahmedabad', 'Gujarat', 380001, 9876543212),
    ('Karan', 'Malhotra', 'karan.malhotra@gmail.com', 28, 'Hyderabad', 'Telangana', 500001, 9654321789),
    ('Neha', 'Gupta', 'neha.gupta87@gmail.com', 29, 'Kolkata', 'West Bengal', 700001, 9123456789),
    ('Vikas', 'Yadav', 'vikas.yadav@gmail.com', 31, 'Pune', 'Maharashtra', 411001, 9345678901),
    ('Anjali', 'Mehra', 'anjali.mehra@gmail.com', 26, 'Jaipur', 'Rajasthan', 302001, 9765432187),
    ('Siddharth', 'Chopra', 'sid.chopra@gmail.com', 33, 'Lucknow', 'Uttar Pradesh', 226001, 9456783210),
    ('Rohan', 'Kapoor', 'rohan.kapoor@gmail.com', 35, 'Chandigarh', 'Chandigarh', 160001, 9876549876)
]

cur.executemany("INSERT INTO Customers VALUES (?,?,?,?,?,?,?,?)", Customers) #? is a placeholder -> for each row

cur.execute("select * from customers")
cur.fetchone() #fetch one row

cur.fetchmany(5) #fetch 5 rows

cur.fetchall() #fetch all rows

"""##**Format your results**"""

from tabulate import tabulate

# Fetch all items from the database
cur.execute("SELECT * FROM customers")
items = cur.fetchall()

# Prepare data for the table
headers = ['First Name', 'Last Name', 'Email', 'Age', 'City', 'State', 'Zip', 'Phone']
formatted_items = [list(item) for item in items]

# Print formatted table
print(tabulate(formatted_items, headers=headers, tablefmt='grid'))

# Fetch all items from the database
cur.execute("SELECT * FROM customers")
items = cur.fetchall()

# Define a header
print(f"{'First Name':<12}{'Last Name':<12}{'Email':<25}{'Age':<5}{'City':<15}{'State':<15}{'Zip':<10}{'Phone':<15}")
print("-" * 115)

# Iterate and print rows
for item in items:
    print(f"{item[0]:<12}{item[1]:<12}{item[2]:<25}{item[3]:<5}{item[4]:<15}{item[5]:<15}{item[6]:<10}{item[7]:<15}")

"""# **RowId Concept in SQLite**

## **Introduction**
In SQLite, every row in a table has a unique identifier called the `RowId`. This `RowId` is a 64-bit signed integer that SQLite automatically assigns to each row in a table, unless the table is explicitly created with a `WITHOUT ROWID` clause or uses a column explicitly defined as `INTEGER PRIMARY KEY`.

---

## **Key Characteristics of RowId**
1. **Uniqueness:**
   - The `RowId` is guaranteed to be unique within a table.
   
2. **Default Behavior:**
   - If no `INTEGER PRIMARY KEY` is defined in the table, SQLite automatically creates a `RowId` for each row.

3. **Alias for `RowId`:**
   - SQLite provides three aliases for the `RowId`:
     - `rowid`
     - `_rowid_`
     - `oid`
   - These can be used interchangeably in SQL queries.

4. **Explicit Integer Primary Key:**
   - If a table defines a column with `INTEGER PRIMARY KEY`, SQLite uses that column's value as the `RowId`.

5. **Accessing the RowId:**
   - You can retrieve the `RowId` explicitly even if it's not part of the table schema.

---

## **Benefits of Using RowId**
- **Efficient Access:**
  - Rows can be accessed more efficiently using the `RowId` as it serves as a built-in index.
  
- **Automatic Handling:**
  - SQLite automatically manages `RowId` values for new rows.

- **Flexibility:**
  - The `RowId` provides a fallback mechanism for identifying rows in tables without primary keys.

"""

from tabulate import tabulate

# Fetch all items from the database
cur.execute("SELECT rowid, * FROM customers")
items = cur.fetchall()

# Prepare data for the table
headers = ['Row_id','First Name', 'Last Name', 'Email', 'Age', 'City', 'State', 'Zip', 'Phone']
formatted_items = [list(item) for item in items]

# Print formatted table
print(tabulate(formatted_items, headers=headers, tablefmt='grid'))

"""# **WHERE Clause in SQLite**

## **Introduction**
The `WHERE` clause in SQLite is used to filter records in a table based on specific conditions. It is a crucial part of SQL queries, allowing you to retrieve, update, or delete only the rows that meet the criteria specified in the `WHERE` condition.

---

## **Key Features**
1. **Filter Rows:**
   - The `WHERE` clause limits the rows affected by a query based on the specified condition.

2. **Supported Operators:**
   - SQLite supports various operators for comparisons:
     - **Comparison Operators:** `=`, `!=`, `<`, `>`, `<=`, `>=`
     - **Logical Operators:** `AND`, `OR`, `NOT`
     - **Set Operators:** `IN`, `NOT IN`
     - **Pattern Matching:** `LIKE`, `GLOB`
     - **NULL Check:** `IS NULL`, `IS NOT NULL`
     - **Range Check:** `BETWEEN ... AND ...`

3. **Flexible Conditions:**
   - The `WHERE` clause can include multiple conditions combined using logical operators.


"""

cur.execute("select * from customers where age>28 and email like '%gmail%'")

items = cur.fetchall()

for item in items:
  print(item)

"""# **Update Statement**"""

cur.execute("""
UPDATE Customers SET age = 26 WHERE rowid = 1
""")

cur.execute("select * from customers where rowid=1")
cur.fetchall()

"""# **Delete Records**"""

cur.execute("Delete from customers where rowid=2")

cur.execute("select * from customers where rowid=2")
cur.fetchall() #empty list is returned

"""# **Order By**"""

cur.execute("Select * from customers order by age desc")

items = cur.fetchall()

for item in items:
  print(item)

"""# **And/OR**"""

cur.execute("select * from customers where age=26 and city='Delhi'")
cur.fetchall()

cur.execute("select * from customers where age=26 or city='Delhi'")
cur.fetchall()

"""# **Limit**"""

cur.execute("select * from customers limit 5")
items = cur.fetchall()
for item in items:
  print(item)

conn.close() #close our connection

